import{_ as e,c as a,o as l,a4 as n}from"./chunks/framework.GYzjcnJh.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{"date":"2024-03-24 08:34:52"},"headers":[],"relativePath":"devops/loadbalance/index.md","filePath":"devops/loadbalance/index.md"}'),i={name:"devops/loadbalance/index.md"},s=n(`<h2 id="负载均衡类型" tabindex="-1">负载均衡类型 <a class="header-anchor" href="#负载均衡类型" aria-label="Permalink to &quot;负载均衡类型&quot;">​</a></h2><p>四层：</p><ul><li>LVS：Linux Virtual Server</li><li>Nginx：1.9版之后</li><li>HAProxy：High Availability Proxy</li></ul><p>七层：</p><ul><li>HAProxy</li><li>Nginx</li></ul><h2 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h2><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-lighter vp-code" tabindex="0"><code><span class="line"><span style="color:#E2931D;">四层：Redis、Mysql、RabbitMQ、Memcached等</span></span>
<span class="line"><span style="color:#E2931D;">七层：Nginx、Tomcat、Apache、PHP、图片、动静分离、API等</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>##　四层负载</p><p>在LVS 传统的四层负载设备中，把client发送的报文目标地址(原来是负载均衡设备的IP地址)，根据负载均衡器设置的调度算法选择对应的web服务器，这样client就可以直接跟后端服务器建立TCP连接并发送数据，而四层负载负载器自身不参与建立连接</p><h2 id="七层负载" tabindex="-1">七层负载 <a class="header-anchor" href="#七层负载" aria-label="Permalink to &quot;七层负载&quot;">​</a></h2><p>七层负载均衡器起了一个反向代理服务器的作用，服务器建立一次TCP连接要三次握手，而client要访问Web Server要先与七层负载负载器进行三次握手后建立TCP连接，把要访问的报文信息发送给七层负载均衡；然后七层负载均衡再根据设置的均衡规则选择特定的 Web Server，然后通过三次握手与此台Web Server建立TCP连接，然后Web Server把需要的数据发送给七层负载均衡设备，负载均衡设备再把数据发送给client；</p><p>所以，七层负载均衡设备起到了代理服务器的作用，七层代理需要和Client和后端服务器分别建立连接</p>`,12),t=[s];function r(o,c,p,d,h,b){return l(),a("div",null,t)}const m=e(i,[["render",r]]);export{u as __pageData,m as default};
