import{_ as e,c as s,o as r,a4 as a}from"./chunks/framework.GYzjcnJh.js";const k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"k8s/k8s-cri.md","filePath":"k8s/k8s-cri.md"}'),n={name:"k8s/k8s-cri.md"},o=a(`<h2 id="概述" tabindex="-1">概述 <a class="header-anchor" href="#概述" aria-label="Permalink to &quot;概述&quot;">​</a></h2><blockquote><p><strong>CRI 标准由 **Google 和红帽主导推出*</strong>*<strong>，用于将 Kubernetes 平台和特定的容器运行时解耦</strong></p></blockquote><p><a href="https://www.cnblogs.com/zhangmingcheng/p/17495311.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/zhangmingcheng/p/17495311.html</a></p><p>在 CRI 出现之前（也就是 Kubernetes v1.5 之前），Docker 作为第一个容器运行时，Kubelet 通过<strong>硬编码的方式直接调用 Docker API</strong>，进而达到一个面向终态的效果。</p><p>在这之后，又出现了一种新的容器运行时 <code>rkt</code>，它也想要成为 Kubernetes 支持的一个容器运行时，当时它也合到了 Kubelet 的代码之中。这两个容器运行时的加入使得 Kubernetes 的代码越来越复杂、难以维护。之后 <code>hyber.sh</code> 加入社区，也想成为第三个容器运行时。</p><p>此时就有人站出来说，我们能不能对容器运行时的操作抽象出一个接口，将 Kubelet 代码与具体的容器运行时的实现代码解耦开，只要实现了这样一套接口，就能接入到 Kubernetes 的体系中，这就是我们后来见到的 <code>Container Runtime Interface (CRI)</code></p><h2 id="kubernetes1-24之后版本使用docker作为容器运行时" tabindex="-1"><strong>Kubernetes1.24之后版本使用docker作为容器运行时</strong> <a class="header-anchor" href="#kubernetes1-24之后版本使用docker作为容器运行时" aria-label="Permalink to &quot;**Kubernetes1.24之后版本使用docker作为容器运行时**&quot;">​</a></h2><h3 id="cri-dockerd" tabindex="-1">cri-dockerd <a class="header-anchor" href="#cri-dockerd" aria-label="Permalink to &quot;cri-dockerd&quot;">​</a></h3><p><a href="https://github.com/Mirantis/cri-dockerd/releases" target="_blank" rel="noreferrer">github 发布页面</a></p><p><strong>安装cri-docker，确保节点已提前装好docker容器运行时</strong></p><div class="language-bash line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki material-theme-lighter vp-code" tabindex="0"><code><span class="line"><span style="color:#E2931D;">wget</span><span style="color:#91B859;"> https://github.com/Mirantis/cri-dockerd/releases/download/v0.3.11/cri-dockerd-0.3.11-3.el8.x86_64.rpm</span></span>
<span class="line"><span style="color:#E2931D;">rpm</span><span style="color:#91B859;"> -ivh</span><span style="color:#91B859;"> cri-dockerd-0.3.11-3.el8.x86_64.rpm</span></span>
<span class="line"><span style="color:#E2931D;">systemctl</span><span style="color:#91B859;"> daemon-reload</span></span>
<span class="line"><span style="color:#E2931D;">systemctl</span><span style="color:#91B859;"> enable</span><span style="color:#91B859;"> --now</span><span style="color:#91B859;"> cri-docker</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div>`,11),t=[o];function c(l,p,i,d,h,b){return r(),s("div",null,t)}const m=e(n,[["render",c]]);export{k as __pageData,m as default};
