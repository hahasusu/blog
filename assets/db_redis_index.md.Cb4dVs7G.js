import{_ as e,c as a,o as i,a4 as t}from"./chunks/framework.GYzjcnJh.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"db/redis/index.md","filePath":"backend/db/redis/index.md"}'),d={name:"db/redis/index.md"},r=t('<h2 id="单线程" tabindex="-1">单线程 <a class="header-anchor" href="#单线程" aria-label="Permalink to &quot;单线程&quot;">​</a></h2><p>redis4.0已经支持多线程了</p><p>redis的网络IO和键值对读写是由一个线程完成的</p><p>但Redis的其它功能，持久化，异步删除，集群数据同步是多个线程的</p><p>总的来说, 整个Redis来说，是多1.</p><h2 id="为什么快" tabindex="-1">为什么快 <a class="header-anchor" href="#为什么快" aria-label="Permalink to &quot;为什么快&quot;">​</a></h2><ol><li>基于内存</li><li>数据结构简单</li><li>多路复用和非阻塞IO</li><li>避免上下文切换</li></ol><p>对于Redis来说，性能的瓶颈主要是内存和网络带宽，不是CPU</p><h2 id="缓存的实现流程" tabindex="-1">缓存的实现流程 <a class="header-anchor" href="#缓存的实现流程" aria-label="Permalink to &quot;缓存的实现流程&quot;">​</a></h2><p><img src="http://pic.justdoiit.top/imgs/2024-03-01-1709262110.webp" alt="" loading="lazy"></p>',10),o=[r];function s(l,n,c,p,_,h){return i(),a("div",null,o)}const b=e(d,[["render",s]]);export{u as __pageData,b as default};
