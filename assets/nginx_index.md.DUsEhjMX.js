import{_ as e,c as r,o,a4 as t}from"./chunks/framework.GYzjcnJh.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"nginx/index.md","filePath":"backend/nginx/index.md"}'),a={name:"nginx/index.md"},n=t('<h2 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h2><p>首先要明白，Nginx 采用的是多进程（单线程） + 多路 IO 复用模型。使用了 I/O 多路复用技术的 Nginx，就成了 并发事件驱动 的服务器。</p><p><strong>多进程的工作模式</strong></p><ul><li>Nginx 在启动后，会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个相互独立的 worker 进程。工作进程以非特权用户运行。</li><li>master 进程主要用来管理 worker 进程，包含：接收来自外界的信号，向各 worker 进程发送信号，监控 worker 进程的运行状态，当 worker 进程退出后（异常情况下），会自动重新启动新的 worker 进程。</li><li>worker 进程则是处理基本的网络事件。多个 worker 进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个 worker 进程中处理，一个 worker 进程，不可能处理其它进程的请求。</li></ul><p>工作线程处理实际的请求。Nginx 使用基于事件的模型和依赖操作系统的机制来有效地在工作进程之间分发请求。</p><blockquote><p>worker 进程数，一般会设置成机器 CPU 核数。因为更多的 worker 数，只会导致进程相互竞争 CPU，从而带来不必要的上下文切换。 使用多进程模式，不仅能提高并法率，而且进程之间相互独立，一个 worker 进程挂了不会影响其他 worker 进程。</p></blockquote><h2 id="惊群现象" tabindex="-1">惊群现象 <a class="header-anchor" href="#惊群现象" aria-label="Permalink to &quot;惊群现象&quot;">​</a></h2><ul><li>主进程（master 进程）首先通过 socket() 来创建一个 sock 文件描述符用来监听，然后 fork 生成子进程（workers 进程），子进程将继承父进程的 sockfd（socket 文件描述符），之后子进程 accept() 后将创建已连接描述符（connected descriptor）），然后通过已连接描述符来与客户端通信。</li><li>那么，由于所有子进程都继承了父进程的 sockfd，那么当连接进来时，所有子进程都将收到通知并 争着 与它建立连接，这就叫 惊群现象。大量的进程被激活又挂起，只有一个进程可以 accept() 到这个连接，这当然会消耗系统资源。</li></ul><p><strong>参考</strong></p><p><a href="https://tsejx.github.io/devops-guidebook/server/nginx/install" target="_blank" rel="noreferrer">https://tsejx.github.io/devops-guidebook/server/nginx/install</a></p>',10),i=[n];function s(l,c,d,k,p,_){return o(),r("div",null,i)}const g=e(a,[["render",s]]);export{x as __pageData,g as default};
